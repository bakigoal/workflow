# Workflow Engine (FSM)

## Обзор

Проект реализует лёгкий асинхронный workflow-движок, основанный на подходе конечного автомата (FSM).

Решение ориентировано на долгоживущие банковские бизнес-процессы, где важны:

- надёжность,
- возможность pause / resume,
- повторные попытки (retry / backoff),
- безопасное конкурентное выполнение.

Логика процесса конфигурируется через БД, а исполнение шагов остаётся в коде.

---

## Основные сущности

### Process Instance

Экземпляр выполнения бизнес-процесса.

- Хранится в таблице process_instance
- Является источником истины состояния процесса
- start_time и end_time определяют жизненный цикл

---

### Step Instance

Экземпляр выполнения шага процесса.

- В каждый момент времени у процесса только один активный шаг
- end_time = null → шаг выполняется
- Хранится в таблице step_instance

---

### Transfer (Переход)

Описывает допустимые переходы между шагами.

- Конфигурируется в таблице transfer
- Содержит:
- тип процесса
- исходный шаг
- сигнал
- целевой шаг
- Позволяет менять логику процесса без деплоя

---

### Signal

Сигнал, возвращаемый step-handler’ом.

- null → выполнение процесса приостанавливается
- Ненулевой сигнал → выбирается следующий переход

---

Модель выполнения процесса

1. Процесс запускается (REST / scheduler / событие)
2. Engine определяет активный шаг
3. Выполняется соответствующий step-handler
4. Handler возвращает:
   - Signal — продолжение процесса
   - null — пауза
5. Состояние фиксируется в БД
6. Процесс может быть продолжен позже

---

### Pause / Resume

Пауза реализована явно:

- Handler возвращает null
- Транзакция завершается
- Процесс остаётся в консистентном состоянии
- Resume — повторный запуск engine с новым сигналом

Никакое состояние не хранится в памяти.

---

### Retry и Backoff

Повторные попытки реализованы data-driven:

- В БД хранятся:
- счётчик попыток
- next_retry_at
- Scheduler выбирает только готовые к повтору шаги
- Backoff позволяет избежать retry-штормов

---

### Saga и компенсации

Каждый шаг может иметь компенсационное действие.

- Компенсации выполняются тем же FSM-механизмом
- Подходит для долгоживущих транзакций
- Обеспечивает согласованность распределённых операций

---

### Конкурентное выполнение

Engine безопасен для параллельного запуска:

- Используется optimistic locking
- Только один поток может продвинуть процесс
- Конкурентные попытки завершаются корректно

Позволяет горизонтально масштабировать выполнение без DB-локов.

---

### Почему не BPMN / Camunda / Temporal

Решение сознательно сделано минималистичным:

- нет визуального моделирования
- низкая операционная сложность
- прозрачное состояние в БД
- легко отлаживать и сопровождать

BPM-платформы оправданы для других классов задач.

---

### Технологический стек

- Java 21
- Spring Boot 3 (Spring MVC)
- PostgreSQL
- JPA / Hibernate
- Liquibase
- Kafka (опционально)
- Docker / Kubernetes

---

Типовые сценарии использования

- Онбординг клиентов
- Процессы согласования
- Асинхронные интеграции
- Retryable внешние вызовы
- Saga-процессы

---

Принципы проектирования

- Явное состояние
- Data-driven переходы
- Идемпотентность
- Безопасность при сбоях
- Минимальная инфраструктура

---

Статус

Проект отражает production-подход к реализации workflow-движков
для банковских и enterprise-систем.